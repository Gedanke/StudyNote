# 函数与优化方法: 模型的自我学习(上)

上节课咱们一同学习了有关模型训练的一些概念和术语，明确了这些概念之后我们来了解一下模型学习过程中的两个非常重要的概念，损失函数和优化方法。

深度学习，包含了三个部分：模型表征（包括模型设计、网络表示等）、模型评估（之前提到的准确召回和刚才说的损失函数等）、优化算法。模型表征包括模型设计、网络表示等，模型评估即我在《03 | AI 术语：让你变得更加专业》中讲到的精准率、召回率等评估指标，以及这一节我要讲到的损失函数，而优化算法同样也是我在这一节要介绍。

损失函数、代价函数和目标函数
模型的学习，实际上就是对参数的学习。参数学习的过程需要一系列的约束，这个约束就是损失函数。我们先来看损失函数与代价函数。

损失函数与代价函数
咱们回想一下人类的学习过程。假设我们要跟小朋友介绍狮子，我们会给他几张狮子的照片，并告诉他狮子都有哪些特征。小朋友以后就知道，当看到一只动物满足这些特征的时候，它就是狮子。但是小朋友一般要多看几次才能记住狮子的样子，并且狮子尾巴的长短，皮毛颜色的深浅，鬃毛的浓密程度等，都会影响他的判断。不断认清狮子的过程就是一个不断调整自己认知的过程。

训练模型也是一样的。模型一开始什么也不知道，此时如果我们输入一个数据，模型的输出是没有意义的，所以，我们要给它更多的数据。模型每次拿到数据，都要将自己的输出和真实的结果进行比较，如果偏差很大，它就要对这个偏差进行反馈，想办法减少这种偏差，也就是学习更多的特征，直到学会如何对输入数据进行正确的判断。

这就是机器学习的一个抽象的过程。说起来很简单，但其中需要很多知识和概念。

我们来看一个例子：



我们现在有一些数据样本，需要用一条函数曲线去拟合它的分布，经过某种方式学习后，我们得到了 3 种曲线：







黄色曲线，我们假定其函数式为 f1，函数跟样本点的拟合较差，基本上都不在曲线上。我们称为“欠拟合”。

红色曲线，我们假定其函数式为 f2，虽然把每个样本点都拟合到位了，但是如果我们新增一个点，红色曲线就拟合不好了。而且这条曲线实在太过复杂，很难用一个相对简单的函数表达式去表示。这个情况就是我在《01 | 从神经元说起：数学篇》讲到的“过拟合”。

绿色曲线，我们假定其函数式为 f3，这个函数看起来似乎好了很多。这条曲线看起来很简单，意味着参数少、好表示，并且每个样本点都离曲线很近，没有大的偏差。

假定这几个样本点的真实函数式为 F(x)，我们拟合出来的函数式为 f(x)。那么，对于每一个样本点，真实值和拟合值之间就存在了一个误差，我们可以通过一个公式来表示这个误差：L(x)=(F(x)-f(x))2。通过这个计算函数，我们可以知道用这个拟合函数去表示真实函数时，表示效果的好坏，我们称这个函数为损失函数（loss fuction）。损失函数越小，拟合函数就能越好的拟合真实函数。

需要说明的是，损失函数的种类很多，我们稍后会介绍几种常见的损失函数。

但实际上，我们手里的样本点还是挺多的，它们构成了一个训练集。我们将训练集上所有点的拟合误差做一个平均，可以用如下的函数进行表示：



这个函数我们称为代价函数（cost function），这种训练集数据的平均损失，我们称为经验风险。同样，只要我们将经验风险最小化，那么拟合出来的函数就会更接近实际的函数。

一般来说，损失函数是针对一个样本，而代价函数是针对一个数据集，即所有样本的，但我们在实际工作中并不会严格区分它们。

目标函数
当我们把经验风险最小化的同时，就意味着我们要尽力照顾到所有的样本点，那我们得到的函数有可能就成为前面红色的曲线，产生“过拟合”。同时也会让曲线变得复杂，带来更多的参数。

于是我们就需要解决两个问题：如何尽可能地减少参数，以及如何不要产生过拟合。

想一想，是不是我们在损失函数后面加上一个能够衡量模型复杂度的函数，让模型简单点，参数少一点就好了？

那什么函数可以让模型变得简单，或者让模型尽量不要过拟合呢？对的，就是我在“01 课时”提到的范数：L1 范数可以实现权值稀疏，L2 范数则用来防止过拟合。

我们在损失函数后面加上度量模型复杂度的函数 J(f)，称作正则化（regularization）。L1 和 L2 范数是较为常用的度量模型复杂度的函数。训练集的平均损失为经验风险，这个度量模型的复杂度函数项我们就称为结构风险。

由此，我们将经验风险和结构风险同时最小化，就得到了如下的函数：



函数的第一部分就是刚才说的损失函数，J(f)就是正则化项，λ 为正则化项系数。

我们可以把 λ 看成是一种惩罚因子，如果我们不希望模型的结构风险太大，那么就可以增大 λ，这样模型就会朝着减小参数复杂度的方向训练。在实际项目开发中，正则化项不用在一开始添加，可以先只用带有经验风险项的损失函数来训练模型，模型训练结束后，再尝试加入正则化项，且 λ 也需要人为或者按照一定规律进行不断的调整和尝试。

常用损失函数
前面提到，损失函数是用来估量模型的预测值与真实值的不一致的程度。为了衡量这种不一致，人们提出了很多不同类型的损失函数，用于不同的场景和问题。这里我会介绍几个最常用的损失函数：0-1 损失函数、平方损失函数、均方差损失函数、交叉熵损失函数和 Softmax 损失函数。我们依次来看。

0-1 损失函数

我们评估一个分类模型的时候，最简单的评估方法就是：如果模型预测对了，我们就认为损失函数的值为 0，如果模型预测错了就给出 1。这个就是最简单的 0-1 损失函数，公式化的表示就是：



但 0-1 损失函数不能求导，所以在深度学习中，无法被应用于反向传播（关于反向传播，我会在《05｜前馈网络与反向传播：模型的自我学习（下）》中讲到）。0-1 损失函数是最简单的损失函数，它具有十分重要的意义。

平方损失函数

上文中咱们在介绍损失函数的时候，讲到这样一个公式：L(x)=(F(x)-f(x))2。这个就是平方损失函数，它直接测量了机器学习模型的输出与实际结果之间的距离，一般多用于回归问题。

均方误差损失函数

均方误差（Mean Squared Error，MSE）是回归损失函数中最常用的误差，它是预测值与目标值之间差值的平方和。其公式化表示为：



其中 s 为目标值的向量表示，y 为预测值的向量表示。

交叉熵损失函数

说到交叉熵，你是不是想到了之前咱们在“01 课时”中提到的熵，也就是如下函数：



我们把函数的格式稍微改变一下就得到了交叉熵损失函数（Cross entropy loss）的公式：



其中，p(x) 表示真实概率分布，q(x) 表示预测概率分布。

通过函数不难发现，交叉熵损失函数实际上就是通过缩小两个概率分布的差异（误差），来使预测的概率分布尽可能达到真实的概率分布，一般多用于分类问题。

Softmax 损失函数

在学习 Softmax 损失函数之前，我们先来回顾一下我在《02 | 从神经元说起：结构篇》中讲到的 Softmax 函数。Softmax 函数是深度学习中使用非常频繁的一个函数，它可以把输入的几个数映射为 0-1 之间的实数，并且归一化后仍能够保证几个数的和为 1。它的公式化表示为：



假设有一个数组，共有 T 个元素，其中第 j 个元素的 Softmax 值就可以通过上面的公式计算得到，即该元素的指数与所有元素指数和的比值。

回到刚才的交叉熵损失函数公式中的 q(xi)，也就是预测的概率分布，如果我们换成 Softmax 方式的表示，即为：



该损失函数我们就称为Softmax 损失函数（Softmax loss），也称为 Softmax with cross-entropy loss，它是交叉熵损失函数的一个特例，和交叉熵损失函数一样，一般也用于分类问题。

损失函数的种类非常多，我在这里先介绍几个常用的种类，在后续的实战环节中，我们还会遇到更多的损失函数，到时候我会对其进行详细的介绍。

优化方法之梯度下降
有了约束（损失函数），模型就可以根据它来学习，而这个学习又要使用到优化方法，也就是模型如何学习或更新。

优化算法实际上做的就是如何在模型表征的空间中找到模型评估效果指标最好的模型的过程。具体来说，假定我们有一个函数 f(x)， 我们需要找到一组参数权重，使 f(x)的值最小。常见的优化方法包括梯度下降法、牛顿法和拟牛顿法、共轭梯度法等，种类和变体非常多，不同的优化方法适用场景有所不同，但目的都是为了寻找最优的模型。

这些优化方法，在实际的深度学习模型研发过程中，都已经有了现成的封装好的函数，直接使用即可。但是为了更好地理解深度学习模型的内部机制，我们有必要了解它们。这一课时，我就来带你了解最经典的梯度下降法（Gradient Descent）。

梯度下降法是最早、最简单，也是使用最多的优化方法。为了便于理解，我们通过一个下山的例子来看。

假设现在有一座山，你站在山顶，但是你有点饿，想赶紧下山，去饭店吃饭，那此时我们该怎么办呢？



在不考虑性命危险的情况下，最快的方法就是：哪个地方坡度大，哪个地方最陡峭，就往哪里走。于是，在确认自己的位置之后，我们就可以对比当前所在位置的所有方向，寻找坡度下降最快的方向，然后往前走一步到达新的位置，再寻找新的位置所有方向中下坡度最陡的方向，如此反复，直到达到最低点。

这就是梯度下降法最直观的表示。还记得我在“01 课时”抛出的结论吗？“梯度向量的方向即为函数值增长最快的方向”。这个结论的实际应用之一就是梯度下降法。



具体来说，在一个三维空间曲线中，任何一点我们都能找到一个与之相切的平面（更高维则是超平面），这个平面上有无穷多个方向，但是只有一个是曲线函数下降最快的梯度。每次优化我们都沿着最快下降的梯度方向进行，这就是梯度下降。

下山的过程中，方向很关键，但是步子大小也同样重要。步子太大了，就可能跑到别的山谷中，也有可能永远也走不到饭店的位置，最后每次都要多走一段然后再走回来，反反复复地在接近和远离饭店的路上大踏步地走动（在模型训练中，这种反复称为“震荡”）；但步子太小就要计算很多次，还没有走到饭店，人就饿死了。

这个步子的大小，在算法中就是参数的学习率（learning rate）。绝大多数情况下，因为步长的存在，我们不可能走到最精确的最低点，最后会在最小值的某一个区域内反复震荡。这个误差我们是可以接受的，如果在一段时间内误差没有发生新的变化，那我们就可以近似地认为训练已经收敛了。

批量梯度下降法（Batch Gradient Descent，BGD）
假设有一个线性回归函数模型，y 是真实的数据分布函数，hθ(x)是我们拟合的函数，θ 是参数，也是我们要求的权值。那我们整个优化的过程，就是为了找到最好的 θ。损失函数J(θ)可以表示为：



其中，m 表示样本数量。要想拟合真实分布，那么损失函数就要最小（误差最小），为了得到这个最小值，我们就要使用梯度，即“梯度向量的方向即为函数值增长最快的方向”，让损失函数以最快的速度减小。

因此，我们要先对 J(θ)中的 θ 求偏导数，这样就可以得到每个 θ 对应的梯度：



得到了每个 θ 的梯度之后，我们就可以按照下降的方向去更新每个 θ：



其中α为学习率。更新 θ 后，我们就得到一个更新之后的损失函数，它的值也就更小了，我们就越接近要拟合的函数了。

从以上过程我们可以看到，这个方式的优化可以得到全局的最优解，因为每次都会使用所有的 m 个样本。但在很多的场景中，样本很多，如果每走一步就要动用全部的数据，会造成十分庞大的计算量。因此，在数据量大的场合我们一般不推荐使用批量梯度下降法。为了解决这个问题，随机梯度下降法就出现了。

随机梯度下降法（Stochastic Gradient Descent，SGD）
不同于批量梯度下降法，随机梯度下降每次只使用一个随机选择的样本来更新θ，则更新过程变成了：



SGD 在每轮迭代中，会根据随机选择的一条数据对应的损失函数值来优化，这样一来，即便样本数量很大，整个过程也只需要使用其中一部分数据就可以完成更新了。每一轮参数的更新速度会大大加快，能够更快地得到最优解。

但 SGD 带来高速和便捷的同时，也带来了一些风险。

比如，我们的训练数据中不可避免地会存在错误样本，即噪声数据。如果在一次更新中好巧不巧的，就是使用了噪声数据，就会造成一定程度的准确度的下降，这一次优化就不是朝着最好的方向发展了。此外，因为每次只用一个样本进行优化，而单个样本并不能代表全体样本的情况，所以可能会收敛到局部最优。

随机梯度下降方法用损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了最终总体的优化效率的提高。当然，这个过程中增加的迭代次数是要远远小于样本的数量的。

小批量梯度下降法（Mini-Batch Gradient Descent, MBGD）
MBGD 的方法实际上相当于批量梯度下降和随机梯度下降的折中，即每次使用一个固定数量的数据进行优化。这个固定数量，就是 Batch Size。

不同于批量梯度下降，该方法每次选择一个 Batch（例如 32、64 等）进行优化，这会显著减少每次的计算量，提高收敛的速度。并且，在实际的计算过程中，引入了矩阵计算，让该方法计算速度并不比 SGD 慢太多。

需要注意的是，Batch Size 也是一个不断尝试的参数，过大过小都不好。如果 Batch Size 太大，每次计算的样本数就大，计算量就会急剧增大，内存或者显存的空间占用也就大；如果太小，则达不到 Batch Size 的初衷。

基于随机梯度下降法，人们又提出了 Momentum、Nesterov Momentum 等方法，这部分知识你如果有兴趣可以自行查阅学习。

总结
恭喜你完成了这一课时的学习。本课时我介绍了深度学习中的损失函数、代价函数、目标函数以及典型的优化方法。由于深度学习的应用范围非常广，其损失函数、优化方法也非常多，更多的知识我会在后续用到的时候再进行讲解。没有提及的部分，通过本课时你也可以触类旁通，遇到其他的损失函数和优化方法快速了解它们的意义。

你还有特别想了解的损失函数和优化方法吗？对于我介绍的损失函数和优化方法，你有什么见解吗？欢迎在留言区分享。

下一节课，我将带你了解前馈网络与反向传播。

